from decimal import *

# constant that indicates the precision of the pi value generated by the formula - the bigger the number the more accurate assumption of pi will be generated
PRECISION = 1000
FIRST_DECIMAL_NUMBER_INDEX = 2
FIRST_DIGIT_OF_PI = "3"


def reverse_n_pi_digits(n: int) -> str:
    """
    The function calculates n digits of pi and returns the digits in a reverse order in a string form
    :param n: the amount of digits to return - a natural number
    :type n: int
    :return: a string containing n digits of pi in reverse order
    :rtype: str
    """
    getcontext().prec = n  # setting the amount of digits to be generated
    pi = FIRST_DIGIT_OF_PI + str(nilakantha(PRECISION))[FIRST_DECIMAL_NUMBER_INDEX:]  # removing the dot from the number
    return pi[::-1]  # reversing the string generated


def nilakantha(reps: int) -> Decimal:
    """
        The function generates an assumption of pi according to the Nilakantha Series formula which says that pi = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) ...
        the more numbers you use the better - the pi estimation will be more accurate
        the function than returns the number generated
        :param reps: the amount of numbers to use
        :type reps: int
        :return: the pi estimation generated
        :rtype: Decimal
        """
    result = Decimal(3.0)
    op = 1      # the formula starts with addition and then transitions to subtraction
    # the first number that we use to divide in the formula is 2
    for n in range(2, 2 * reps + 1, 2):
        result += 4 / Decimal(n * (n + 1) * (n + 2) * op)
        op *= -1        # changing the operation done(addition -> subtraction or subtraction -> addition)
    return result
